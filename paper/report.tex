% report.tex
% Final Report for MIT 6.858 
% Jeff Stewart and Veer Dedhia

\documentclass[journal]{IEEEtran}
\usepackage{cite}
\usepackage{url} 

\begin{document}
%
\title{ROP Compiler}

\author{Jeff~Stewart,
        Veer~Dedhia}


% The paper headers
\markboth{MIT 6.858}{}

% make the title area
\maketitle

\section{Introduction}

%Here is where we put Motivation.
  % why a ROP compiler is needed
When developing exploits for modern x86 64-bit systems, attackers must handcraft
exploits for each binary. This involves finding a vulnerability (such
as a stack-based buffer overflow) and diverting control flow (overwrite return
address). Modern exploits employ Return-Oriented Programming to bypass widely
deployed defenses such as W\^{}X.

Building a ROP chain requires manual effort to find suitable gadgets out of the
multitude of existing code snippets, and then chaining those gadgets together in
the correct order to call functions or execute injected code. x86 64-bit systems
present some challenges that do not exist on other platforms. For example, the
64-bit calling convention primarily uses register arguments, as opposed to
stack-pushed arguments on many 32-bit systems. This requires finding gadgets to
set values in registers, instead of using an overflow to write to the stack.
Many tools exist to help at various stages of exploit building, but no public
compiler is available to fully create these ROP chains.

We present a simple ROP Compiler, developed to more easily generate ROP chains,
given a binary and goal. We demonstrate our compiler on both a proof-of-concept
simple binary, as well as a well-known utility, rsync. Our tool generates
working ROP chains to inject and call shellcode, or call other functions.

\subsection{Background}
Control flow hijacking is an extremely dangerous attack vector. They allow an
attacker to divert the intended program flow, and instead execute instructions
that further the attacker's goals. These may include spawning a reverse shell or
installing malware. This gives the attacker a foothold on the machine towards a
larger goals, such as financial fraud or exfiltration of sensitive data.

  % existing defenses (ASLR (pie), w^x)
Modern computer systems employ various defenses, such as W\^{}X and ASLR, that
protect against different types of control flow hijacking. W\^{}X works by
disabling execution of writable memory, such as the stack. This prevents an
attacker from injecting malicious code as user-supplied input and directly
diverting control flow to that address.

ASLR (address space layout randomization) works by loading a given binary at a random offset in memory for
each execution. Libraries (libc, etc.) use position-independent code (PIC),
so that they may be shared amongst processes or loaded separately. Binaries that
support ALSR are known as position-independent executables (PIE), which means
all references to addresses in the code are RIP-relative. Non-PIE binaries have
hardcoded addresses, and they do not support ASLR.


  % what is ROP (why it matters)

With these defenses widely deployed, attackers have turned away from simpler
techniques (code injection), and have instead developed control hijacking that
reuses existing program code. This easily bypasses W\^{}X, since the code is
already allowed to execute. Libraries, such as libc, provide many functions that
an attacker would like to call (execve, mprotect, etc.). As such, the first
techniques focused on setting up stack arguments and then diverting control to a
library function (return-to-libc).

However, this technique is limited to calling a single function, whose arguments
come from the stack. An attack goal may require calls to functions whose
arguments come from registers or setting up other prerequisites, however, so
chaining becomes the necessary next step. Return-Oriented Programming (ROP) \cite{rop} is a
technique developed to generalize the return-to-libc attacks by chaining
snippets of code that end in 'ret' (called gadgets). Most modern exploits leverage ROP to bypass existing defenses.

  % why existing ones aren't too usable
      % other existing tools, and their problems
There do exist some tools that find gadgets and suggest ROP chains, such as Q \cite{schwartz2011q},
ROPC \cite{ropc}, mona.py \cite{mona}, and ROPgadget \cite{ropgadget}. However, these tools are either not available (Q),
do not work on realistic x86 64-bit binaries (ROPC, mona.py), or are not fully
featured (ROPgadget).


\section{Implementation Details}
Our ROP Compiler is separated into four main components: the goal interpreter, the gadget finder, gadget classifier, and the gadget scheduler.

\subsection{Goal Interpreter}
The goal interpreter provides the necessary configuration data for the ROP compiler.
This configuration data is supplied by the exploit author and is comprised of three separate components:
\begin{enumerate}
  \item A list of files to extract gadgets from.  For PIE executables and libraries, each files should include the address that it was loaded to.
  \item A list of libraries to extract metadata from.  This list of libraries will be used for obtaining function metadata for use later, as described in \ref{scheduler}.
  \item A list of the author's desired goals.  Each goal item can be one of three types: \emph{Function}, \emph{ShellcodeAddress}, \emph{Shellcode}.
  \emph{Function} goals indicate the author wishes to call a given function with a set of specified arguments.  
  \emph{ShellcodeAddress} goals indicate the author wishes to run a set of shellcode that already exists in the target program's address space.
  The \emph{Shellcode} goal indicates the author wishes to run a set of shellcode that does not already exists in the target program's address space.
  Thus, the \emph{Shellcode} goal must first load the shellcode into memory before it may continue.
\end{enumerate}
These 3 goals were chosen to allow the exploit author to obtain arbitrary code execution, while also specifying the minimum amount of work that is necessary.
For instance, there is no need to use a \emph{Shellcode} goal, if the exploit author already knows the address of their shellcode in memory.

\subsection{Gadget Finder}
The gadget finder iterators over all of the available binaries and searches for gadgets.
This is accomplished by walking each byte of the executable sections in the and trying to disassemble the last \textbf{N} number of bytes.
If these series of bytes ends in a RET or JMP instruction, then these series of bytes is saved as a potential gadget.
For disassembly, our ROP compiler makes use of the Capstone framework \cite{capstone}.

The choice of \textbf{N} is compromise between the speed of the ROP compiling process, and the number of gadgets found.
As the larger gadgets tend to be more complex (and thus less useful during ROP compiling), increasing \textbf{N} is not necessarily the best option.
Our implementation makes the compromise of setting \textbf{N} to 10.
A future version may iteratively increase \textbf{N} upon failing to compile an adequate ROP chain.

\subsection{Gadget Classifier}
The gadget classifier analyzes each of the potential gadgets to determine which type(s) of gadget they are.
Our classifier's implementation is based of the design of Q's classifier as presented by Schwartz et al. \cite{schwartz2011q}.
Schwartz proposed classifying gadget into 9 types useful for generating ROP chains.
Our implementation classifies our potential gadgets into the 8 gadget types shown in \ref{tab:gadgetTypes} (excluding NoOpG gadgets from \cite{schwartz2011q}).

\begin{table*}[t]
  \begin{center}
    \begin{tabular}{ | l | l | l | l | }
    \hline
    Name & Input & Parameters & Semantic Definition \\
    \hline
    JumpG & AddrReg & & RIP <- AddrReg \\
    MoveRegG & InReg, OutReg & & OutReg <- InReg \\
    LoadConstG & OutReg & Value & OutReg <- Value \\
    ArithmeticG & InReg1, InReg2, OutReg & Op & OutReg <- InReg1 Op InReg2 \\
    LoadMemG & AddrReg, OutReg & Offset & OutReg <- M[AddrReg + Offset] \\
    StoreMemG & AddrReg, InReg & Offset & M[AddrReg + Offset] <- InReg \\
    ArithmeticLoadG & AddrReg, OutReg & Offset, Op & OutReg Op<-  M[AddrReg + Offset] \\
    ArithmeticStoreG & AddrReg, InReg & Offset, Op & M[AddrReg + Offset] Op<- InReg \\

      \hline
    \end{tabular}
    \caption{Gadget Types}
  \end{center}
  \label{tab:gadgetTypes}
\end{table*}

Similar to the classifier proposed by Schwartz, our implementation uses the weakest precondition technique.
For each gadget, we generate a symbolic formula for the instructions.
This formula is then used to concretely emulate the gadget by substituting random values for any initial registers used and memory reads.
The output registers and memory writes are then used to evaluate which, if any, of the gadget type preconditions hold true.
This process is then done a number of times.
Any preconditions left unviolated throughout all of the concrete executions reveal the gadget type.

While Q \cite{schwartz2011q} and ROPC \cite{ropc} take this process one step further, by utilizing a SMT solver to verify the gadgets; our implementation does not do so.
In our brief analysis and examples (described in \ref{examples}), we have not seen a gadget that has been misclassified using only the concrete emulation.
Thus, to improve the ROP compilation speed, our implementation does not verify gadgets.
Any of the necessary metadata (such as what registers clobbered by a gadget) is extracted from the symbolic formula.

\subsection{Gadget Scheduler}\label{scheduler}
The gadget scheduler combines classified gadgets into the individual goals.
These goals are accomplished by iterating over the classified gadgets to find a series of ones that match the required goal. 
For example, to write a value to memory, the scheduler looks for a LoadMemG gadget to set the address, another LoadMemG gadget to set the value, and a StoreMemG to actually write to memory.
The scheduler keeps track of the registers to ensure that one used in the beginning of a chain does not clobber one needed later in the chain.

While the \emph{Function} and \emph{ShellcodeAddress} goals are relatively straight forward to implement, the \emph{Shellcode} goal requires more work. 
In order to execute the exploit author's shellcode, our scheduler first must write the shellcode to memory.
This is accomplished by querying the goal interpreter for a writable section of memory and then chaining together a series of write memory chains as previously described.
Once the shellcode has been stored to memory, the \emph{Shellcode} goal can be accomplished through the same means as a \emph{ShellcodeAddress} goal.

A final situation that requires additional work is calling external functions in libraries.
While calling functions within the main binary's Procedure Linkage Table (PLT) is relatively simple, calling a function not imported into the PLT requires substantially more work.
To accomplish this task, the scheduler must first read from the target process's GOT for a function which the target process does use.
Next, the scheduler adds the offset from this base function to the target function.
As offsets within a library are constant under traditional ASLR, the computed value will be the address of the target function.
Our scheduler implements this approach by finding a chain of the following gadgets:
\begin{enumerate}
  \item LoadMemG from the stack to set the address of the base entry to read in the GOT.
  \item LoadMemG to read the base entry in the GOT.
  \item LoadMemG from the stack to set the offset from the base entry to the target entry in the library.
  \item ArithmeticG to add the offset from the base entry to the target entry in the GOT.
  \item One LoadMemG per arguments for the target function to set the argument's value.
  \item JumpG to jump to the function in the library.
\end{enumerate}
The scheduler scans for each gadget while making sure any values used in the later gadgets (such as the computed function's address) aren't clobbered by the earlier gadgets.

\section{Example Usage}\label{examples}

\subsection{Buffer Overflow Proof of Concepts}
In order to provide a test suite for our ROP compiler, we've implemented a series of proof of concept stack buffer overflow exploits.
These example proof of concept programs exercise the different components of the compiler.
This test suite includes:
\begin{enumerate}
  \item A buffer overflow which calls mprotect from the PLT to change memory permissions and execute shellcode already existing in memory.
  \item A buffer overflow which calls the syscall function from the PLT to change memory permissions and execute shellcode already existing in memory.
  \item A buffer overflow which calls mprotect from the PLT to change memory permissions and execute shellcode not already existing in memory.
  \item A buffer overflow which calls system from the PLT to run a command.
  \item A buffer overflow which reads the address of printf in the GOT, adds the offset from printf to mprotect in libc, calls
  mprotect to change memory permissions, and execute shellcode not already existing in memory.
\end{enumerate}

\subsection{rsync}
In order to illustrate a real world use of our ROP compiler, we implemented an exploit for rsync in it.
As the current rsync\footnote{rsync 3.1.1, current as of 12/6/15} does not have any publicly known vulnerabilities, we introduced a synthetic stack buffer overflow into rsync.
This stack buffer overflow vulnerability was introduced into rsync's filter file argument processing code.
rsync provides the ability to filter the files that are copied through the use of a filter file that specifies which files to exclude.
As this vulnerability is a file format bug, there is little chance for the attacker to leak information about the memory layout of rsync (as compared to a network reachable bug).
Thus, a working exploit must be able to load shellcode at a known address.
The exploit is further complicated by the need to call mprotect without it being in rsync's PLT.

Our exploit, provided in \emph{rsync.py}, utilizes an automatically generated ROP chain that handles these issues.
The resulting ROP chain is 464 bytes that loads and executes a 33 byte execve-based shellcode.
This ROP chain was generated in 71 seconds.

\section{Future Work}
  % Synthesizing new gadgets by combining ones
Our compiler, while functional, could be improved to provide additional advanced
features. For example, we would like to explore synthesizing new gadgets by
combining existing small gadgets. This may require using symbolic execution to
analyze side-effects. Using symbolic execution would also allow us to more
easily analyze larger gadgets, as the side-effects may be more complex. We would
also like to expand our attack goal language to allow for more expressive goals.
This would allow more complex exploits, such as reading or modifying data
structures in memory. A third feature we would like to implement is exploit
hardening (as discussed by Q).

\bibliographystyle{plain}
\bibliography{sources.bib}{}

\end{document}
