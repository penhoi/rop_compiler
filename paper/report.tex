% report.tex
% Final Report for MIT 6.858 
% Jeff Stewart and Veer Dedhia

\documentclass[journal]{IEEEtran}
\usepackage{cite}
\usepackage{url} 

\begin{document}
%
\title{ROP Compiler}

\author{Jeff~Stewart,
        Veer~Dedhia}


% The paper headers
\markboth{MIT 6.858}{}

% make the title area
\maketitle

\section{Introduction}

%Here is where we put Motivation.
  % why a ROP compiler is needed
When developing exploits for modern x86 64-bit systems, attackers must handcraft
exploits for each binary. This involves finding a vulnerability (such
as a stack-based buffer overflow) and diverting control flow (overwrite return
address). Modern exploits employ Return-Oriented Programming to bypass widely
deployed defenses such as W\^X.

Building a ROP chain requires manual effort to find suitable gadgets out of the
multitude of existing code snippets, and then chaining those gadgets together in
the correct order to call functions or execute injected code. x86 64-bit systems
present some challenges that do not exist on other platforms. For example, the
64-bit calling convention primarily uses register arguments, as opposed to
stack-pushed arguments on many 32-bit systems. This requires finding gadgets to
set values in registers, instead of using an overflow to write to the stack.
Many tools exist to help at various stages of exploit building, but no public
compiler is available to fully create these ROP chains.

We present a simple ROP Compiler, developed to more easily generate ROP chains,
given a binary and goal. We demonstrate our compiler on both a proof-of-concept
simple binary, as well as a well-known utility, rsync. Our tool generates
working ROP chains to inject and call shellcode, or call other functions.

\subsection{Background}
Control flow hijacking is an extremely dangerous attack vector. They allow an
attacker to divert the intended program flow, and instead execute instructions
that further the attacker's goals. These may include spawning a reverse shell or
installing malware. This gives the attacker a foothold on the machine towards a
larger goals, such as financial fraud or exfiltration of sensitive data.

  % existing defenses (ASLR (pie), w^x)
Modern computer systems employ various defenses, such as W\^X, and ASLR, that
protect against different types of control flow hijacking. W\^X works by
disabling execution of writable memory, such as the stack. This prevents an
attacker from injecting malicious code as user-supplied input and directly
diverting control flow to that address.

ASLR (address space layout randomization) works by loading a given binary at a random offset in memory for
each execution. Libraries (libc, etc.) use position-independent code (PIC),
so that they may be shared amongst processes or loaded separately. Binaries that
support ALSR are known as position-independent executables (PIE), which means
all references to addresses in the code are RIP-relative. Non-PIE binaries have
hardcoded addresses, and they do not support ASLR.


  % what is ROP (why it matters)

With these defenses widely deployed, attackers have turned away from simpler
techniques (code injection), and have instead developed control hijacking that
reuses existing program code. This easily bypasses W\^X, since the code is
already allowed to execute. Libraries, such as libc, provide many functions that
an attacker would like to call (execve, mprotect, etc.). As such, the first
techniques focused on setting up stack arguments and then diverting control to a
library function (return-to-libc).

However, this technique is limited to calling a single function, whose arguments
come from the stack. An attack goal may require calls to functions whose
arguments come from registers or setting up other prerequisites, however, so
chaining becomes the necessary next step. Return-Oriented Programming (ROP) is a
technique developed to generalize the return-to-libc attacks by chaining
snippets of code that end in 'ret' (called gadgets). Most modern exploits leverage ROP to bypass existing defenses.

  % why existing ones aren't too usable
      % other existing tools, and their problems
There do exist some tools that find gadgets and suggest ROP chains, such as Q,
ropc, mona.py, and ROPGadget. However, these tools are either not available (Q),
do not work on realistic x86 64-bit binaries (ropc, mona.py), or are not fully
featured (ROPGadget).


\section{Implementation Details}
Our ROP Compiler is separated into four main components: the goal interpreter, the gadget finder, gadget classifier, and the gadget scheduler.

\subsection{Goal Interpreter}
The goal interpreter provides the necessary configuration data for the ROP compiler.
This configuration data is supplied by the exploit author and is comprised of three separate components:
\begin{enumerate}
  \item A list of files to extract gadgets from.  For PIE executables and libraries, each files should include the address that it was loaded to.
  \item A list of libraries to extract metadata from.  This list of libraries will be used for obtaining function metadata for use later, as described in \ref{scheduler}.
  \item A list of the author's desired goals.  Each goal item can be one of three types: \emph{Function}, \emph{ShellcodeAddress}, \emph{Shellcode}.
  \emph{Function} goals indicate the author wishes to call a given function with a set of specified arguments.  
  \emph{ShellcodeAddress} goals indicate the author wishes to run a set of shellcode that already exists in the target program's address space.
  The \emph{Shellcode} goal indicates the author wishes to run a set of shellcode that does not already exists in the target program's address space.
  Thus, the \emph{Shellcode} goal must first load the shellcode into memory before it may continue.
\end{enumerate}
These 3 goals were chosen to allow the exploit author to obtain arbitrary code execution, while also specifying the minimum amount of work that is necessary.
For instance, there is no need to use a \emph{Shellcode} goal, if the exploit author already knows the address of their shellcode in memory.

\subsection{Gadget Finder}
The gadget finder iterators over all of the available binaries and searches for gadgets.
This is accomplished by walking each byte of the executable sections in the and trying to disassemble the last \textbf{N} number of bytes.
If these series of bytes ends in a RET or JMP instruction, then these series of bytes is saved as a potential gadget.
For disassembly, our ROP compiler makes use of the Capstone framework \cite{capstone}.

The choice of \textbf{N} is compromise between the speed of the ROP compiling process, and the number of gadgets found.
As the larger gadgets tend to be more complex (and thus less useful during ROP compiling), increasing \textbf{N} is not necessarily the best option.
Our implementation makes the compromise of setting \textbf{N} to 10.
A future version may iteratively increase \textbf{N} upon failing to compile an adequate ROP chain.

\subsection{Gadget Classifier}
The gadget classifier analyzes each of the potential gadgets to determine which type(s) of gadget they are.
Our classifier's implementation is based of the design of Q's classifier as presented by Schwartz et al. \cite{schwartz2011q}.
Schwartz proposed classifying gadget into 9 types useful for generating ROP chains.
Our implementation classifies our potential gadgets into the 8 gadget types shown in \ref{tab:gadgetTypes} (excluding NoOpG gadgets from \cite{schwartz2011q}).

\begin{table*}
  \begin{center}
    \begin{tabular}{ | l | l | l | l | }
    \hline
    Name & Input & Parameters & Semantic Definition \\
    \hline
    JumpG & AddrReg & & RIP <- AddrReg \\
    MoveRegG & InReg, OutReg & & OutReg <- InReg \\
    LoadConstG & OutReg & Value & OutReg <- Value \\
    ArithmeticG & InReg1, InReg2, OutReg & Op & OutReg <- InReg1 Op InReg2 \\
    LoadMemG & AddrReg, OutReg & Offset & OutReg <- M[AddrReg + Offset] \\
    StoreMemG & AddrReg, InReg & Offset & M[AddrReg + Offset] <- InReg \\
    ArithmeticLoadG & AddrReg, OutReg & Offset, Op & OutReg Op<-  M[AddrReg + Offset] \\
    ArithmeticStoreG & AddrReg, InReg & Offset, Op & M[AddrReg + Offset] Op<- InReg \\

      \hline
    \end{tabular}
    \label{tab:gadgetTypes}
    \caption{Gadget Types}
  \end{center}
\end{table*}

Similar to the classifier proposed by Schwartz, our implementation uses the weakest precondition technique.
For each gadget, we generate a symbolic formula for the instructions.
This formula is then used to concretely emulate the gadget by substituting random values for any initial registers used and memory reads.
The output registers and memory writes are then used to evaluate which, if any, of the gadget type preconditions hold true.
This process is then done a number of times.
Any preconditions left unviolated throughout all of the concrete executions reveal the gadget type.

While Q \cite{schwartz2011q} and ROPC \cite{ropc} take this process one step further, by utilizing a SMT solver to verify the gadgets; our implementation does not do so.
In our brief analysis and examples (described in \ref{examples}), we have not seen a gadget that has been misclassified using only the concrete emulation.
Thus, to improve the ROP compilation speed, our implementation does not verify gadgets.
Any of the necessary metadata (such as what registers clobbered by a gadget) is extracted from the symbolic formula.

\subsection{Gadget Scheduler}\label{scheduler}
The gadget scheduler combines classified gadgets into the individual goals.
These goals are accomplished by iterating over the classified gadgets to find a series of ones that match the required goal. 
For example, to write a value to memory, the scheduler looks for a LoadMemG gadget to set the address, another LoadMemG gadget to set the value, and a StoreMemG to actually write to memory.
The scheduler keeps track of the registers to ensure that one used in the beginning of a chain does not clobber one needed later in the chain.

While the \emph{Function} and \emph{ShellcodeAddress} goals are relatively straight forward to implement, the Shellcode goal requires more work. 

How our compiler interacts with existing defenses (ASLR, w\^x)



\section{Example Usage}\label{examples}
  - bof.py
  - rsync

\section{Future Work}
  - Synthesizing new gadgets by combining ones

\bibliographystyle{plain}
\bibliography{sources.bib}{}

\end{document}
